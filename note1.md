# 파이썬 코딩기술 #1

## 파이썬답게 생각하기

pythonic '파이썬답다' 형용사

## 1. 사용 중인 파이썬의 버전을 알아두라

### 파이썬 버전을 정확히 아는방법

```jsx
$ python3 --version
```

현재 실행중인 파이썬 버전을 확인하는 방법으로 sys 내장 모듈을 활용하여 확인

```jsx
>>> import sys
>>> print(sts.version_info)
sys.version_info(major=3, minor=9, micro=6, releaselevel='final', serial=0)
>>> prtint(sys.version)
3.9.6 (default, Jun 29 2021, 05:25:02)
[Clang 12.0.5 (clang-1205.0.22.9)]
```

### 정리

파이썬2의 지원이 안되고 있으므로 파이썬3를 통해 프로젝트를 진행해야 한다.

## 2. PEP8 스타일 가이드를 따르라

파이썬 개선 제안 (Python Enhancement Proposal) #8, 파이썬 코드를 어떤 형식으로 작성할지 알려주는 스타일 가이드이다. 

### 공백

파이썬에서 공백은 중요하다. 공백은 코드의 가독성에 있어 영향을 끼치기 때문에 중요하다.

```python
Tab 대신 Space를 사용해서 들여쓰기를 해라
긴 식을 다음 줄에 이어서 쓸 경우에는 일반적인 들여쓰기보다 4 spacce를 더 들여쓴다
각 함수와 클래스 사이에는 빈 줄을 두줄 넣는다.
클래스 안에서  메서드와 메서드 사이에는 빈 줄을 한줄 넣는다.
dict 에서 키와 : 사이에는 공백을 넣지 않고, 한 줄 안에 키와 값을 같이 넣는 경우에는 :  다음에 space를 하나 추가한다.
변수 대입에서 = 전후에는 스페이스를 하나씩만 넣는다.
타입 표기를 덧붙이는 경우 변수 이름과 : 사이에, : 과 타입 정보 사이에 공백을 넣지 않는다.
: 과 타입 정보 사에는 공백을 추가해야 한다.
```

### 명명 규약

```python
함수, 변수, 애트리뷰트는 test_name 와 같이 Snake case 규칙을 적용
보호해야 하는 인스턴스 애트리 뷰트는 일반적인 Snake case를 사용하되 _test_name 같이 언더바로 시작한다.
비공개 (한 클래스 안에서만 쓰이고 다른 곳에서는 쓰면 안되는 경우)인스턴스 애트리뷰트는 Snake case를 따르되,
__test_name처럼 언더바 2개로 시작한다.
클래스는 CamelCase 규칙을 따른다.
모듈 수준의 상수는 ALL_CAP 처럼 모든 글자를 대문자로 하고 단어와 단어 사이에 언더바로 연결한다. 클래스안에 있는 인스턴스 메서드는  첫 번째 인자의 이름을 반드시 self를 사용한다. 클래스 메서드는 클래스를 첫 번재 인자의 이름으로 반드시 cls를 사용해야 한다.
```

### 식과 문

파이썬은 문제를 해결할 명백한 방법이 하나 있고, 가급적이면 유일해야 한다라는 가르침을 따라 식과 문장을 작성한다.

```python
# false case
if not a is b:
  pass

# true case 
if a is not b:
  pass
```

```python
빈 컨테이너 시퀀스([], ‘’)를 검사할 때는 길이로 비교하지 않는다.
비어있는 경우 체크를 할 경우 True로 나온다.

if, for, while 등등 짧은 경우 명확성을 위해서 except를 사용하지 않고
각 부분을 여러 줄에 나눠 배치한다.

식이 길어질 경우 줄바꿈과 들여쓰기로 읽기 쉽게 한다.
#long case
if (long_name_value is a or
			long_name_vlue is not None):
```

### 임포트

PEP8은 모듈 임포트하여 코드에 사용하는 방법도 제시한다.

import시 항상 파일 맨 앞에 위치 하시키고, 절대적인 이름을 사용해야 하며, 현 모듈의 절대 적인 경로를 사한다. 반드시 상대적인 경로로 import시 from . import foo처럼 명시적인 구문을 사용한다.

import 순서는 표준 라이브러리, 서드 파트, 자체 제작 모듈 순서로 섹션을 나눈다. 각 섹션에서는 알파벳 순서로 진행된다.

### 요약

파이선 코드 작성시 PEP8 style guide를 따른다. 일관성 있는 스타일을 사용해야 추후 유지보수에 비용이 적게 든다.

## 3. byte와 str의 차이를 알아두라

파이썬에는 문자열 데이터의 시퀀스를 표현하는 byte와 strdlek라는 두가지 타입이 존재한다.

```python
# byte 타입의 인스턴스에서는 부호가 없는 8 바이트, 데이터가 그대로 들어간다.
>>> a = b'abcdefg'
>>> print(list(a))
[97, 98, 99, 100, 101, 102, 103]
>>> print(a)
b'abcdefg'
#str 인스턴스에는 유니코드 코드 포인트 가 들어있다.
>>> a = 'abcdefg'
>>> print(list(a))
['a', 'b', 'c', 'd', 'e', 'f', 'g']
>>> print(a)
abcdefg
```

정리하면 각 타입 별로 대응하는 이진 인코딩, 텍스트 인코딩이 없다. 인코딩 또는 디코딩을 하려면 encode, decode 메서드를 호출해야한다. default 인코딩으로는 UTF-8이다.

## 4. C 스타일 형식의 문자열을 str.format보다는 f-문자열을 통한 인터폴레이션을 사용하라

### C 스타일 형식 문자열의 4가지 문제점

- 형식화 식에서 오른쪽에 있는 tuple 내 데이터 값의 순서를 바꾸거나 값의 타입을 바꾸면 타입 변환이 불가능
- 형식화를 하기 전 값을 변경해야 한다면 식을 읽기가 매우 어렵다.
- 형식화 문자열에서 같은 값을 여러번 사용해야 한다면 여러번 반복해야 한다.
- 형식화 식에 dict를 사용하면 식이 길어지고 시각적으로 잡음이 많다.

### 인터폴레이션을 통한 형식 문자열

파이썬 3.6부터 인터폴레이션을 통한 형식 문자열이 도입이 되어 형식 문자열 앞에 f 문자를 붙이면 된다.

장점으로 표현력을 극대화 하고 4번째 문제점이 제거 된다.

형식화 식 안에서 현재 파이썬 영역에서 사용할 수 있는 모든 이름을 자유롭게 참조할 수 있도록 허용함으로 간결함을 제공한다.

```python
>>> temp = '하와이'
>>> result = f'니가 가라 {temp}'
>>> print(result)
니가 가라 하와이
```

### 요약

str.format 메서드는 유용하지만 c 스타일 형식 문자열의 문제점이 존재한다. 그러한 문제점을 해결하는 f-문자열을 사용하라

## 5. 복잡한 식을 쓰는 대신 도우미 함수를 작성하라

파이썬의 문법이 간결하여 상당한 로직이 들어가는 식도 한 줄로 쉽게 작성할수 있다.

만약 반복적인 로직이나 상당한 식으로 복잡성이 높아지면 바로 식을 더 작은 조각으로 나누어서 로직을 도우는 함수로 옮겨야 한다.

 ‘반복하지 말라’는 뜻의 DRT원칙을 따라야 한다.

## 6. 인덱스를 사용하는 대신 대입을 사용해 데이터를 언패킹하라

파이썬엔느 값으로 이뤄진 불편(Immutable) 순서쌍을 만들수 있는 tuple 타입이 있다. 가장 짧은 튜플은 dict key-value 쌍과 비슷하게 두 값으로 이루어진다.

```python
>>> snack_calories = {
...     '감자칩': 140,
...     '팝콘': 80,
...     '땅콩': 190,
... }
>>> items = tuple(snack_calories.items())
>>> print(items)
(('감자칩', 140), ('팝콘', 80), ('땅콩', 190))
```

튜플이 만들어지면, 인덱스를 통해 새 값을 대입해서 튜플을 변경할 수 없다. 

파이썬에는 언패킹이라는 독특한 방식이 존재하는데

인덱스를 사용해 각 값에 접근하는 대신 이 튜플을 두 변수로 한번에 받을수 있다.

```python
>>> print(f'{a}, {b}, {c}')
감자칩, 팝콘, 땅콩
```

### 요약

파이썬은 여러 값을 한번에 대입할 수 있는 언패킹이라는 독특한 문법을 제공한다. 파이썬 언패킹은 일반적으로 사용할수 있으므로 모든 이터러블에 적용할수 있다. 그리고 이터러블이 여러 계층으로 포함 하고 있는 경우에도 언패킹을 적용할 수 있다.

인덱스를 사용해 시퀀스 내부에 접근하는 대신 언패킹을 사용하면 시각적인 잡음이 줄어들고 코드의 명확성이 올라간다.

## 7. range 보다는 enumerate를 사용하라

range 내장 함수는 어떤 정수 집합을 이터레이션하는 루프가 필요할때 유용하다.

enumerate는 루프 인덱스와 이터레이터의 다음 값으로 이뤄진 쌍을 넘겨준다.

```python
#next 내장 함수 사용
>>> brand_list = ['삼성', '애플', '엘지']
>>> temp = enumerate(brand_list)
>>> next(temp)
(0, '삼성')
>>> next(temp)
(1, '애플')
>>> next(temp)
(2, '엘지')
```

### 요약

enumerate를 사용하면 이터레이터에 대해 루프를 돌면서 이터레이터에서 가져오는 원소의 인덱스 까지 코드를 간결히 작성 가능하다. 

range 보다는 enumerate를 사용하는것을 추천한다.

## 여러 이터레이터에 대해 나란히 루프를 수행하려면 zip을 사용하라

```python
>>> food_list = ['감자', '고구마', '버섯']
>>> brand_list = ['삼성', '엘지', '애플']
>>> for foood, brand in zip(food_list, brand_list):
...     print(f'{food} {brand}')
감자 삼성
고구마 엘지
버섯 애플
```

zip은 자신을 감싼이터레이터 중 어느 하나가 끝날 때까지 튜플을 전달한다.

zip은 튜플을 지연 계산하는 제너레이터를 만든다. 따라서 무한히 긴 입력에서 zip을 쓸 수 있다.

itertools에있는 zip_longest를 사용하면 존재하지 않는 값은 자신에게 전달된 fillvalue로 대신한다. 디폴트는 None이다.

```python
>>> from itertools import zip_longest
>>> food_list = ['감자', '고구마', '버섯', '마늘', '계란']
>>> brand_list = ['삼성', '엘지', '애플']
>>> for brand, food in zip_longest(brand_list, food_list):
...     print(f'{brand}, {food}') 
... 
삼성, 감자
엘지, 고구마
애플, 버섯
None, 마늘
None, 계란
```

### 요약

zip 내장 함수를 사용하면 여러 이터레이터를 한번에 나란히 이터레이션을 할 수 있다.

하지만 이터레이터의 길이가 서로 다르면 가장 짧은 이터레이터 길이까지만 진행한다. 그럴경우 itertolls 내장 모듈의 zip_longest 함수를 사용하면 가장 긴 이터레이터 길이까지 진행된다.

## 9. for나 while 루프 뒤에 else 블록 사용하지 말라

```python
for i in range(3):
    print(i)
else:
    print('else block!')
```

else 블록은 루프가 끝나자마자 실행된다. 여기서 else 블록은 '처리할 에외가 없는 경우에 이 블록을 실행한다'는 뜻이다. 그러나, 실제로 루프안에서 break문을 사용하면 else 블록이 실행되지 않는다.

빈 시퀀스, while 루프 조건이 처음부터 False일 경우에도 else 블록이 실행된다.

### 요약

의미가 명확하지 않으므로 절대 사용하지 마라

## 10. 대입식을 사용해 반복을 피하라

대입식은 영어로 assignment expression이며 **왈러스 연산자** 라고도 부른다.

```python
#왈러스 연산자 미사용
a = [1, 2, 3, 4]
n = len(a)
if n > 5:
    print(f"List is too long ({n} elements, expected <= 5)")
#왈러스 연산자 사용시
a = [1, 2, 3, 4]
if (n := len(a)) > 5:
    print(f"List is too long ({n} elements, expected <= 5)")
```

### 요약

대입식에서 왈러스 연산자 (:=)를 사용하면 하나의 식 안에서 변수 이름에 값을 대입하여 이 값을 평가할 수 있고, 중복을 줄일 수 있다.